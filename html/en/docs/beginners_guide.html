<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginner’s Guide</title><style type="text/css">body { background: white; color: black; font-family: sans-serif; line-height: 1.4em; text-align: center; margin: 0; padding: 0; } #banner { background: black; color: #F2F2F2; line-height: 1.2em; padding: .3em 0; box-shadow: 0 5px 10px black; } #banner a { color: #00B140; } #main { text-align: left; margin: 0 auto; min-width: 32em; max-width: 64em; } #menu { float: right; width: 11em; padding: 0 .5em 1em .5em; border-left: 2px solid #DDD; } #content { margin-right: 13.5em; padding: 0 .2em 0 1.5em; } h1 { display: block; font-size: 3em; text-align: left; height: .7em; margin: 0; margin-bottom: .5em; } h1 img { width: 100%; } h2 { text-align: center; } p { text-align: justify; } table.news p { margin-top: 0; } table.news td { vertical-align: baseline; } table.news .date { text-align: right; padding-right: 0.5em; white-space: nowrap; } table.donors td { vertical-align: baseline; } table.donors li { text-align: left; } div.directive { background: #F2F2F2; line-height: 1em; margin: 1em 0 1em -1em; padding: .7em .7em .7em 1em; border-top: 2px solid #DDD; } div.directive th { padding-left: 0; padding-right: .5em; vertical-align: baseline; text-align: left; font-weight: normal; } div.directive td { vertical-align: baseline; } div.directive pre { padding: 0; margin: 0; } div.directive p { margin: .5em 0 0 .1em; font-size: .8em; } a.notrans { color: gray; text-decoration:none; } span.initial { font-size: 200%; float: left; padding-right: 10pt;} ul, ol { margin: .5em 0 1em 1em; padding: 0 .5em; } ol { list-style-position: inside; } li { text-align: justify; padding: .5em 0 0 1px; } .compact li { padding-top: 0; } dl { margin: .5em 0 1em 0; } dt { margin: .5em 0; } .compact dt { margin-bottom: .2em; } dd { margin-left: 1.5em; padding-left: 1px; text-align: justify; } td.list { background: #F2F2F2; } blockquote { margin: 1em 0 1em 1em; padding: .5em; } li blockquote, dd blockquote { margin: .7em 0; } blockquote.note { border: 1px dotted #999; line-height: 1.2em; text-align: justify; } blockquote.example { line-height: 1em; border-left: 1px solid #BBB; } blockquote.example pre { padding: 0; margin: 0; } sup { font-size: 50%; }</style><script>
        (function(w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({
                'gtm.start': new Date().getTime(),
                event: 'gtm.js'
            });
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-TPSP33');
    </script></head><body><div id="banner"><strong>Announcing NGINX Plus R11</strong><br>
        Check out our latest release with easier dynamic module integration, additional TCP/UDP<br> load-balancing features, enhancements to nginScript, support for GeoIP2, and more.
        <a href="https://www.nginx.com/blog/nginx-plus-r11-released/?utm_source=nginxorg&amp;utm_medium=header&amp;utm_campaign=product&amp;utm_content=r11"><em>Explore R11</em></a><br></div><div id="main"><div id="menu"><h1><a href="/"><img src="/nginx.png" alt="nginx"></a></h1><div>english<br><a href="../../ru/docs/beginners_guide.html">русский</a><br><br><a href="../../">news</a><br><a href="../../en/">about</a><br><a href="../../en/download.html">download</a><br><a href="../../en/security_advisories.html">security</a><br><a href="./">documentation</a><br><a href="faq.html">faq</a><br><a href="../../en/books.html">books</a><br><a href="../../en/support.html">support</a><br><br><a href="http://trac.nginx.org/nginx">trac</a><br><a href="http://wiki.nginx.org/">wiki</a><br><a href="http://twitter.com/nginxorg">twitter</a><br><a href="https://www.nginx.com/blog/">blog</a><br></div></div><div id="content"><h2>Beginner’s Guide</h2><table width="100%"><tr><td align="left"><a href="#control">Starting, Stopping, and Reloading Configuration</a><br><a href="#conf_structure">Configuration File’s Structure</a><br><a href="#static">Serving Static Content</a><br><a href="#proxy">Setting Up a Simple Proxy Server</a><br><a href="#fastcgi">Setting Up FastCGI Proxying</a><br></td></tr></table><p>
This guide gives a basic introduction to nginx and describes some
simple tasks that can be done with it.
It is supposed that nginx is already installed on the reader’s machine.
If it is not, see the <a href="install.html">Installing nginx</a> page.
This guide describes how to start and stop nginx, and reload its
configuration, explains the structure
of the configuration file and describes how to set up nginx
to serve out static content, how to configure nginx as a proxy
server, and how to connect it with a FastCGI application.
</p><p>
nginx has one master process and several worker processes.
The main purpose of the master process is to read and evaluate configuration,
and maintain worker processes.
Worker processes do actual processing of requests.
nginx employs event-based model and OS-dependent mechanisms to efficiently
distribute requests among worker processes.
The number of worker processes is defined in the configuration file and
may be fixed for a given configuration or automatically adjusted to the
number of available CPU cores (see
<a href="ngx_core_module.html#worker_processes">worker_processes</a>).
</p><p>
The way nginx and its modules work is determined in the configuration file.
By default, the configuration file is named <code>nginx.conf</code>
and placed in the directory
<code>/usr/local/nginx/conf</code>,
<code>/etc/nginx</code>, or
<code>/usr/local/etc/nginx</code>.
</p><a name="control"></a><center><h4>Starting, Stopping, and Reloading Configuration</h4></center><p>
To start nginx, run the executable file.
Once nginx is started, it can be controlled by invoking the executable
with the <code>-s</code> parameter.
Use the following syntax:
</p> <blockquote class="example"><pre>
nginx -s <i>signal</i>
</pre></blockquote><p> 
Where <i>signal</i> may be one of the following:
</p> <ul class="compact">
<li>
<code>stop</code> — fast shutdown
</li>
<li>
<code>quit</code> — graceful shutdown
</li>
<li>
<code>reload</code> — reloading the configuration file
</li>
<li>
<code>reopen</code> — reopening the log files
</li>
</ul><p> 
For example, to stop nginx processes with waiting for the worker processes
to finish serving current requests, the following command can be executed:
</p> <blockquote class="example"><pre>
nginx -s quit
</pre></blockquote><p> 
</p> <blockquote class="note">This command should be executed under the same user that
started nginx.</blockquote><p> 
</p><p>
Changes made in the configuration file
will not be applied until the command to reload configuration is
sent to nginx or it is restarted.
To reload configuration, execute:
</p> <blockquote class="example"><pre>
nginx -s reload
</pre></blockquote><p> 
</p><p>
Once the master process receives the signal to reload configuration,
it checks the syntax validity
of the new configuration file and tries to apply the configuration provided
in it.
If this is a success, the master process starts new worker processes
and sends messages to old worker processes, requesting them to
shut down.
Otherwise, the master process rolls back the changes and
continues to work with the old configuration.
Old worker processes, receiving a command to shut down,
stop accepting new connections and continue to service current requests until
all such requests are serviced.
After that, the old worker processes exit.
</p><p>
A signal may also be sent to nginx processes with the help of Unix tools
such as the <code>kill</code> utility.
In this case a signal is sent directly to a process with a given process ID.
The process ID of the nginx master process is written, by default, to the
<code>nginx.pid</code> in the directory
<code>/usr/local/nginx/logs</code> or
<code>/var/run</code>.
For example, if the master process ID is 1628, to send the QUIT signal
resulting in nginx’s graceful shutdown, execute:
</p> <blockquote class="example"><pre>
kill -s QUIT 1628
</pre></blockquote><p> 
For getting the list of all running nginx processes, the <code>ps</code>
utility may be used, for example, in the following way:
</p> <blockquote class="example"><pre>
ps -ax | grep nginx
</pre></blockquote><p> 
For more information on sending signals to nginx, see
<a href="control.html">Controlling nginx</a>.
</p><a name="conf_structure"></a><center><h4>Configuration File’s Structure</h4></center><p>
nginx consists of modules which are controlled by directives specified
in the configuration file.
Directives are divided into simple directives and block directives.
A simple directive consists of the name and parameters separated by spaces
and ends with a semicolon (<code>;</code>).
A block directive has the same structure as a simple directive, but
instead of the semicolon it ends with a set of additional instructions
surrounded by braces (<code>{</code> and <code>}</code>).
If a block directive can have other directives inside braces,
it is called a context (examples:
<a href="ngx_core_module.html#events">events</a>,
<a href="http/ngx_http_core_module.html#http">http</a>,
<a href="http/ngx_http_core_module.html#server">server</a>,
and
<a href="http/ngx_http_core_module.html#location">location</a>).
</p><p>
Directives placed in the configuration file outside
of any contexts are considered to be in the
<a href="ngx_core_module.html">main</a> context.
The <code>events</code> and <code>http</code> directives
reside in the <code>main</code> context, <code>server</code>
in <code>http</code>, and <code>location</code> in
<code>server</code>.
</p><p>
The rest of a line after the <code>#</code> sign is considered a comment.
</p><a name="static"></a><center><h4>Serving Static Content</h4></center><p>
An important web server task is serving out
files (such as images or static HTML pages).
You will implement an example where, depending on the request,
files will be served from different local directories: <code>/data/www</code>
(which may contain HTML files) and <code>/data/images</code>
(containing images).
This will require editing of the configuration file and setting up of a
<a href="http/ngx_http_core_module.html#server">server</a>
block inside the <a href="http/ngx_http_core_module.html#http">http</a>
block with two <a href="http/ngx_http_core_module.html#location">location</a>
blocks.
</p><p>
First, create the <code>/data/www</code> directory and put an
<code>index.html</code> file with any text content into it and
create the <code>/data/images</code> directory and place some
images in it.
</p><p>
Next, open the configuration file.
The default configuration file already includes several examples of
the <code>server</code> block, mostly commented out.
For now comment out all such blocks and start a new
<code>server</code> block:
</p> <blockquote class="example"><pre>
http {
    server {
    }
}
</pre></blockquote><p> 
Generally, the configuration file may include several
<code>server</code> blocks
<a href="http/request_processing.html">distinguished</a> by ports on which
they <a href="http/ngx_http_core_module.html#listen">listen</a> to
and by
<a href="http/server_names.html">server names</a>.
Once nginx decides which <code>server</code> processes a request,
it tests the URI specified in the request’s header against the parameters of the
<code>location</code> directives defined inside the
<code>server</code> block.
</p><p>
Add the following <code>location</code> block to the
<code>server</code> block:
</p> <blockquote class="example"><pre>
location / {
    root /data/www;
}
</pre></blockquote><p> 
This <code>location</code> block specifies the
“<code>/</code>” prefix compared with the URI from the request.
For matching requests, the URI will be added to the path specified in the
<a href="http/ngx_http_core_module.html#root">root</a>
directive, that is, to <code>/data/www</code>,
to form the path to the requested file on the local file system.
If there are several matching <code>location</code> blocks nginx
selects the one with the longest prefix.
The <code>location</code> block above provides the shortest
prefix, of length one,
and so only if all other <code>location</code>
blocks fail to provide a match, this block will be used.
</p><p>
Next, add the second <code>location</code> block:
</p> <blockquote class="example"><pre>
location /images/ {
    root /data;
}
</pre></blockquote><p> 
It will be a match for requests starting with <code>/images/</code>
(<code>location /</code> also matches such requests,
but has shorter prefix).
</p><p>
The resulting configuration of the <code>server</code> block should
look like this:
</p> <blockquote class="example"><pre>
server {
    location / {
        root /data/www;
    }

    location /images/ {
        root /data;
    }
}
</pre></blockquote><p> 
This is already a working configuration of a server that listens
on the standard port 80 and is accessible on the local machine at
<code>http://localhost/</code>.
In response to requests with URIs starting with <code>/images/</code>,
the server will send files from the <code>/data/images</code> directory.
For example, in response to the
<code>http://localhost/images/example.png</code> request nginx will
send the <code>/data/images/example.png</code> file.
If such file does not exist, nginx will send a response
indicating the 404 error.
Requests with URIs not starting with <code>/images/</code> will be
mapped onto the <code>/data/www</code> directory.
For example, in response to the
<code>http://localhost/some/example.html</code> request nginx will
send the <code>/data/www/some/example.html</code> file.
</p><p>
To apply the new configuration, start nginx if it is not yet started or
send the <code>reload</code> signal to the nginx’s master process,
by executing:
</p> <blockquote class="example"><pre>
nginx -s reload
</pre></blockquote><p> 
</p><p>
</p> <blockquote class="note">
In case something does not work as expected, you may try to find out
the reason in <code>access.log</code> and
<code>error.log</code> files in the directory
<code>/usr/local/nginx/logs</code> or
<code>/var/log/nginx</code>.
</blockquote><p> 
</p><a name="proxy"></a><center><h4>Setting Up a Simple Proxy Server</h4></center><p>
One of the frequent uses of nginx is setting it up as a proxy server, which
means a server that receives requests, passes them to the proxied servers,
retrieves responses from them, and sends them to the clients.
</p><p>
We will configure a basic proxy server, which serves requests of
images with files from the local directory and sends all other requests to a
proxied server.
In this example, both servers will be defined on a single nginx instance.
</p><p>
First, define the proxied server by adding one more <code>server</code>
block to the nginx’s configuration file with the following contents:
</p> <blockquote class="example"><pre>
server {
    listen 8080;
    root /data/up1;

    location / {
    }
}
</pre></blockquote><p> 
This will be a simple server that listens on the port 8080
(previously, the <code>listen</code> directive has not been specified
since the standard port 80 was used) and maps
all requests to the <code>/data/up1</code> directory on the local
file system.
Create this directory and put the <code>index.html</code> file into it.
Note that the <code>root</code> directive is placed in the
<code>server</code> context.
Such <code>root</code> directive is used when the
<code>location</code> block selected for serving a request does not
include own <code>root</code> directive.
</p><p>
Next, use the server configuration from the previous section
and modify it to make it a proxy server configuration.
In the first <code>location</code> block, put the
<a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a>
directive with the protocol, name and port of the proxied server specified
in the parameter (in our case, it is <code>http://localhost:8080</code>):
</p> <blockquote class="example"><pre>
server {
    location / {
        proxy_pass http://localhost:8080;
    }

    location /images/ {
        root /data;
    }
}
</pre></blockquote><p> 
</p><p>
We will modify the second <code>location</code>
block, which currently maps requests with the <code>/images/</code>
prefix to the files under the <code>/data/images</code> directory,
to make it match the requests of images with typical file extensions.
The modified <code>location</code> block looks like this:
</p> <blockquote class="example"><pre>
location ~ \.(gif|jpg|png)$ {
    root /data/images;
}
</pre></blockquote><p> 
The parameter is a regular expression matching all URIs ending
with <code>.gif</code>, <code>.jpg</code>, or <code>.png</code>.
A regular expression should be preceded with <code>~</code>.
The corresponding requests will be mapped to the <code>/data/images</code>
directory.
</p><p>
When nginx selects a <code>location</code> block to serve a request
it first checks <a href="http/ngx_http_core_module.html#location">location</a>
directives that specify prefixes, remembering <code>location</code>
with the longest prefix, and then checks regular expressions.
If there is a match with a regular expression, nginx picks this
<code>location</code> or, otherwise, it picks the one remembered earlier.
</p><p>
The resulting configuration of a proxy server will look like this:
</p> <blockquote class="example"><pre>
server {
    location / {
        proxy_pass http://localhost:8080/;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
</pre></blockquote><p> 
This server will filter requests ending with <code>.gif</code>,
<code>.jpg</code>, or <code>.png</code>
and map them to the <code>/data/images</code> directory (by adding URI to the
<code>root</code> directive’s parameter) and pass all other requests
to the proxied server configured above.
</p><p>
To apply new configuration, send the <code>reload</code> signal to
nginx as described in the previous sections.
</p><p>
There are many <a href="http/ngx_http_proxy_module.html">more</a>
directives that may be used to further configure a proxy connection.
</p><a name="fastcgi"></a><center><h4>Setting Up FastCGI Proxying</h4></center><p>
nginx can be used to route requests to FastCGI servers which run
applications built with various frameworks and programming languages
such as PHP.
</p><p>
The most basic nginx configuration to work with a FastCGI server
includes using the
<a href="http/ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a>
directive instead of the <code>proxy_pass</code> directive,
and <a href="http/ngx_http_fastcgi_module.html#fastcgi_param">fastcgi_param</a>
directives to set parameters passed to a FastCGI server.
Suppose the FastCGI server is accessible on <code>localhost:9000</code>.
Taking the proxy configuration from the previous section as a basis,
replace the <code>proxy_pass</code> directive with the
<code>fastcgi_pass</code> directive and change the parameter to
<code>localhost:9000</code>.
In PHP, the <code>SCRIPT_FILENAME</code> parameter is used for
determining the script name, and the <code>QUERY_STRING</code>
parameter is used to pass request parameters.
The resulting configuration would be:
</p> <blockquote class="example"><pre>
server {
    location / {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param QUERY_STRING    $query_string;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
</pre></blockquote><p> 
This will set up a server that will route all requests except for
requests for static images to the proxied server operating on
<code>localhost:9000</code> through the FastCGI protocol.
</p></div></div></body></html>
